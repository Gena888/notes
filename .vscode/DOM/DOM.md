Каждый DOM-узел принадлежит определённому классу. Классы формируют иерархию. Весь набор свойств и методов является результатом наследования.

Главные свойства DOM-узла:

nodeType
Свойство nodeType позволяет узнать тип DOM-узла. Его значение – числовое: 1 для элементов,3 для текстовых узлов, и т.д. Только для чтения.

nodeName/tagName
Для элементов это свойство возвращает название тега (записывается в верхнем регистре, за исключением XML-режима). Для узлов-неэлементов nodeName описывает, что это за узел. Только для чтения.

innerHTML
Внутреннее HTML-содержимое узла-элемента. Можно изменять.

outerHTML
Полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem. Вместо этого она заменяет его во внешнем контексте.

nodeValue/data
Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем data. Можно изменять.

textContent
Текст внутри элемента: HTML за вычетом всех <тегов>. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.

hidden
Когда значение установлено в true, делает то же самое, что и CSS display:none.
В зависимости от своего класса DOM-узлы имеют и другие свойства. Например у элементов <input> (HTMLInputElement) есть свойства value, type, у элементов <a> (HTMLAnchorElement) есть href и т.д. Большинство стандартных HTML-атрибутов имеют соответствующие свойства DOM.

Впрочем, HTML-атрибуты и свойства DOM не всегда одинаковы, мы увидим это в следующей главе.


ИЗМЕНЕНИЕ ДОМ


Методы для создания узлов:

    document.createElement(tag) – создаёт элемент с заданным тегом,
    document.createTextNode(value) – создаёт текстовый узел (редко используется),
    elem.cloneNode(deep) – клонирует элемент, если deep==true, то со всеми дочерними элементами.

Вставка и удаление:

    node.append(...nodes or strings) – вставляет в node в конец,
    node.prepend(...nodes or strings) – вставляет в node в начало,
    node.before(...nodes or strings) – вставляет прямо перед node,
    node.after(...nodes or strings) – вставляет сразу после node,
    node.replaceWith(...nodes or strings) – заменяет node.
    node.remove() – удаляет node.

Устаревшие методы:

    parent.appendChild(node)
    parent.insertBefore(node, nextSibling)
    parent.removeChild(node)
    parent.replaceChild(newElem, node)
     Все эти методы возвращают node.

Если нужно вставить фрагмент HTML, то 
elem.insertAdjacentHTML(where, html) вставляет в зависимости от where:

    "beforebegin" – вставляет html прямо перед elem,
    "afterbegin" – вставляет html в elem в начало,
    "beforeend" – вставляет html в elem в конец,
    "afterend" – вставляет html сразу после elem.

Также существуют похожие методы elem.insertAdjacentText и elem.insertAdjacentElement, они вставляют текстовые строки и элементы, но они редко используются.

Чтобы добавить HTML на страницу до завершения её загрузки:

document.write(html)
После загрузки страницы такой вызов затирает документ. В основном встречается в старых скриптах.


РАБОТА С КЛАССАМИ 

Для управления классами существуют два DOM-свойства:

className – строковое значение, удобно для управления всем набором классов.
classList – объект с методами add/remove/toggle/contains, удобно для управления отдельными классами.
Чтобы изменить стили:

Свойство style является объектом со стилями в формате camelCase. Чтение и запись в него работают так же, как изменение соответствующих свойств в атрибуте "style". Чтобы узнать, как добавить в него important и делать некоторые другие редкие вещи – смотрите документацию.

Свойство style.cssText соответствует всему атрибуту "style", полной строке стилей.

Для чтения окончательных стилей (с учётом всех классов, после применения CSS и вычисления окончательных значений) используется:

Метод getComputedStyle(elem, [pseudo]) возвращает объект, похожий по формату на style. Только для чтения.


getComputedStyle требует полное свойство!
Для правильного получения значения нужно указать точное свойство. Например: paddingLeft, marginTop, borderTopWidth. При обращении к сокращённому: padding, margin, border – правильный результат не гарантируется.


РАБОТА С РАЗМЕРАМИ 

фото с разметками по ссылке 
https://learn.javascript.ru/size-and-scroll 

У элементов есть следующие геометрические свойства (метрики):

    offsetParent – ближайший CSS-позиционированный родитель или ближайший td, th, table, body.

    offsetLeft/offsetTop – позиция в пикселях верхнего левого угла относительно offsetParent
    .
    offsetWidth/offsetHeight – «внешняя» ширина/высота элемента, включая рамки.

    clientLeft/clientTop – расстояние от верхнего левого внешнего угла до внутренного. Для операционных систем с ориентацией слева-направо эти свойства равны ширинам левой/верхней рамки. Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то clientLeft включает в своё значение её ширину.

    clientWidth/clientHeight – ширина/высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки.

    scrollWidth/scrollHeight – ширины/высота содержимого, аналогично clientWidth/Height, но учитывают прокрученную, невидимую область элемента.

    scrollLeft/scrollTop – ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла.
Все свойства доступны только для чтения, кроме scrollLeft/scrollTop, изменение которых заставляет браузер прокручивать элемент.


РАЗМЕРЫ И ПРОКРУТКА 

Ширина/высота видимой части документа (ширина/высота области содержимого): document.documentElement.clientWidth/Height

Ширина/высота всего документа с прокрученной частью:

let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);
Прокрутка:

Прокрутку окна можно получить так: window.pageYOffset/pageXOffset.

Изменить текущую прокрутку:

window.scrollTo(pageX,pageY) – абсолютные координаты,
window.scrollBy(x,y) – прокрутка относительно текущего места,
elem.scrollIntoView(top) – прокрутить страницу так, чтобы сделать elem видимым (выровнять относительно верхней/нижней части окна).


КООРДИНАТЫ 

Любая точка на странице имеет координаты:

Относительно окна браузера – elem.getBoundingClientRect().

Относительно документа – elem.getBoundingClientRect() плюс текущая прокрутка страницы.

Координаты в контексте окна подходят для использования с position:fixed, а координаты относительно документа – для использования с position:absolute.

Каждая из систем координат имеет свои преимущества и недостатки. Иногда будет лучше применить одну, а иногда – другую, как это и происходит с позиционированием в CSS, где мы выбираем между absolute и fixed.

Две системы координат связаны следующими формулами:

pageY = clientY + высота вертикально прокрученной части документа.
pageX = clientX + ширина горизонтально прокрученной части документа.




Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.

Отличия от this (=event.currentTarget):

event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.



При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).

    -Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
    -Далее обработчики вызываются на целевом элементе.
    -Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on<event> и addEventListener без третьего аргумента или с третьим аргументом равным false.

Каждый обработчик имеет доступ к свойствам события event:

    -event.target – самый глубокий элемент, на котором произошло событие.
    -event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
    -event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).



