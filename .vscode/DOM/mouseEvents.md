События мыши имеют следующие свойства:

Кнопка: which.

Клавиши-модификаторы (true если нажаты): altKey, ctrlKey, shiftKey и metaKey (Mac).

Если вы планируете обработать Ctrl, то не забудьте, что пользователи Mac обычно используют Cmd, поэтому лучше проверить if (e.metaKey || e.ctrlKey).
Координаты относительно окна: clientX/clientY.

Координаты относительно документа: pageX/pageY.
Относительно окна: 
clientX и clientY.



События mouseover/out возникают, даже когда происходит переход с родительского элемента на потомка. С точки зрения браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным.

Для события mouseover:

event.target – это элемент, на который курсор перешёл.
event.relatedTarget – это элемент, с которого курсор ушёл (relatedTarget → target).
Для события mouseout наоборот:

event.target – это элемент, с которого курсор ушёл.
event.relatedTarget – это элемент, на который курсор перешёл (target → relatedTarget).

Важная особенность события mouseout – оно генерируется в том числе, когда указатель переходит с элемента на его потомка.

События mouseenter/mouseleave похожи на mouseover/mouseout. Они тоже генерируются, когда курсор мыши переходит на элемент или покидает его.

Но есть и пара важных отличий:

    Переходы внутри элемента, на его потомки и с них, не считаются.
    События mouseenter/mouseleave не всплывают.



Drag'n'Drop

    1Поток событий: ball.mousedown → document.mousemove → ball.mouseup (не забудьте отменить браузерный ondragstart).
    2В начале перетаскивания: запоминаем начальное смещение указателя относительно элемента: shiftX/shiftY – и сохраняем его при перетаскивании.
    3Выявляем потенциальные цели переноса под указателем с помощью document.elementFromPoint.

На этой основе можно сделать многое.

    На mouseup – по-разному завершать перенос: изменять данные, перемещать элементы.
    Можно подсвечивать элементы, пока мышь «пролетает» над ними.
    Можно ограничить перетаскивание определённой областью или направлением.
    Можно использовать делегирование событий для mousedown/up. Один обработчик событий на большой зоне, который проверяет event.target, может управлять Drag’n’Drop для сотен элементов.
    И так далее.
    
Существуют фреймворки, которые строят архитектуру поверх этого алгоритма, создавая такие классы, как DragZone, Droppable, Draggable. Большинство из них делают вещи, аналогичные описанным выше. Вы можете и создать вашу собственную реализацию переноса, как видите, это достаточно просто, возможно, проще, чем адаптация чего-то готового.